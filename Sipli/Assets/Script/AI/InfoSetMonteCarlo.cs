using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class InfoSetMonteCarlo : MonoBehaviour
{
    private PieceGenerator pieceGenerator;
    private Game game;
    private GameObject controller;
    private GameObject sipliBoard;

    public string teamColor = "red";

    private Stack<MoveData> AImoveStack;

    private void Start()
    {
        sipliBoard = GameObject.FindGameObjectWithTag("SipliBoard");
        pieceGenerator = sipliBoard.GetComponent<PieceGenerator>();

        controller = GameObject.FindGameObjectWithTag("GameController");
        game = controller.GetComponent<Game>();
        
    }

    private void Update()
    {
        Game cp = controller.GetComponent<Game>();
        if (cp.GetCurrentPlayer() == teamColor && !cp.IsGameOver())
        {
            MonteCarloAI(cp.GetCurrentGameState(), 2, 1.0f);
        }
    }

    public void MonteCarloAI(GameState gameState, int iterations, float explorationParameter)
    {
        Debug.Log("Monte Carlo AI: Starting Monte Carlo simulations");

        // SELECTION

        // Get all pieces controlled by the AI player
        List<GameObject> aiPieces = gameState.GetPiecesByPlayer(teamColor);

        // Filter out pieces without valid moves
        List<GameObject> piecesWithMoves = aiPieces.Where(piece => piece.GetComponent<Piece>().InitiateMovePlates()).ToList();

        for (int i = 0; i < iterations; i++)
        {
            // Clone the current game state to simulate a new game
            GameState clonedState = gameState.Clone();

            if (piecesWithMoves.Count > 0)
            {
                // Select a random piece from the pieces with valid moves
                GameObject selectedPiece = piecesWithMoves[Random.Range(0, piecesWithMoves.Count)];

                // Get the move plates for the selected piece
                selectedPiece.GetComponent<Piece>().InitiateMovePlates();

                // Get the move plates generated by the selected piece
                GameObject[] movePlates = GameObject.FindGameObjectsWithTag("MovePlate");

                Debug.Log("Monte Carlo AI: Moveplate count: " + movePlates.Length);

                // Filter out move plates that lead to occupied spaces
                List<GameObject> validMovePlates = new List<GameObject>();
                List<GameObject> validNonAttackMovePlates = new List<GameObject>();

                foreach (GameObject movePlate in movePlates)
                {
                    MovePlate movePlateScript = movePlate.GetComponent<MovePlate>();

                    if (movePlateScript.GetReference() == selectedPiece)
                    {
                        int targetX = movePlateScript.GetX();
                        int targetY = movePlateScript.GetY();

                        // Check if the target position is empty
                        if (clonedState.GetPosition(targetX, targetY) == null)
                        {
                            validMovePlates.Add(movePlate);

                            if (!movePlateScript.attack)
                            {
                                validNonAttackMovePlates.Add(movePlate);
                            }
                        }
                    }
                }
            

            float attackProbability = 0.7f;

            if (validMovePlates.Count > 0)
            {
                    // Check if the selected piece is an "infinity" piece
                    if (selectedPiece.GetComponent<Piece>().GetName().Contains("_infinity"))
                    {
                        // Reduce the attack probability for "infinity" pieces
                        attackProbability = 0.3f;
                    }

                    if (validNonAttackMovePlates.Count > 0 && Random.value <= attackProbability)
                    {
                        // Select a random valid non-attack move plate
                        GameObject selectedMovePlate = validNonAttackMovePlates[Random.Range(0, validNonAttackMovePlates.Count)];

                        // Get the coordinates of the selected move plate
                        MovePlate movePlateScript = selectedMovePlate.GetComponent<MovePlate>();
                        int targetX = movePlateScript.GetX();
                        int targetY = movePlateScript.GetY();

                        // Make the move in the cloned game state
                        clonedState.MakeMove(selectedPiece, targetX, targetY);
                        Debug.Log("Monte Carlo AI: Made move in iteration " + iterations);
                        GameObject[] destroyMovePlates = GameObject.FindGameObjectsWithTag("MovePlate");
                        for (int a = 0; a < destroyMovePlates.Length; a++)
                        {
                            Destroy(destroyMovePlates[i]); //Be careful with this function "Destroy" it is asynchronous
                        }
                        clonedState.NextPlayerTurn();
                    }
                    else
                    {
                        // No valid non-attack moves, try to find attack move plates
                        List<GameObject> attackPlates = new List<GameObject>();

                        foreach (GameObject movePlate in movePlates)
                        {
                            MovePlate movePlateScript = movePlate.GetComponent<MovePlate>();

                            if (movePlateScript.attack && movePlateScript.GetReference() == selectedPiece)
                            {
                                attackPlates.Add(movePlate);
                            }
                        }

                        if (attackPlates.Count > 0)
                        {
                            // Select a random attack move plate
                            GameObject selectedMovePlate = attackPlates[Random.Range(0, attackPlates.Count)];

                            // Get the coordinates of the selected move plate
                            MovePlate movePlateScript = selectedMovePlate.GetComponent<MovePlate>();
                            int targetX = movePlateScript.GetX();
                            int targetY = movePlateScript.GetY();

                            // Make the move in the cloned game state
                            clonedState.MakeMove(selectedPiece, targetX, targetY);
                            GameObject[] destroyMovePlates = GameObject.FindGameObjectsWithTag("MovePlate");
                            for (int a = 0; a < destroyMovePlates.Length; a++)
                            {
                                Destroy(destroyMovePlates[i]); //Be careful with this function "Destroy" it is asynchronous
                            }
                            clonedState.NextPlayerTurn();
                            Debug.Log("Monte Carlo AI: Made combat move");


                        }
                    }
                }
            }

            //Perform a playout or simulate the rest of the game
            //float score = Simulate(clonedState, iterations);

            //Update the statistics of the moves in the game state
            //UpdateStatistics(gameState, score);
        }

        //Debug.Log("Monte Carlo AI: Monte Carlo simulations completed");

        //// Select the best move based on the statistics
        //GameObject bestMove = SelectBestMove(gameState, explorationParameter);

        //if (bestMove != null)
        //{
        //    Debug.Log("Monte Carlo AI: Selected Best Move");

        //    // Make the selected move in the actual game
        //    MakeMove(bestMove);
        //}
    }

    public float Simulate(GameState state, int iterations)
    {
        Debug.Log("Monte Carlo AI: Starting simulation");

        // Simulate the rest of the game using a random move strategy
        // Replace this with your own simulation logic or AI strategy

        GameState simulationState = state.Clone(); // Create a clone of the initial game state for simulation

        for (int i = 0; i < iterations; i++)
        {
            List<GameObject> pieces = simulationState.GetPiecesByPlayer(simulationState.GetCurrentPlayer());
            if (pieces.Count > 0)
            {
                GameObject selectedPiece = pieces[Random.Range(0, pieces.Count)];
                List<GameObject> validMovePlates = simulationState.GetLegalMovesByPiece(selectedPiece);

                if (validMovePlates.Count > 0)
                {
                    GameObject selectedMovePlate = validMovePlates[Random.Range(0, validMovePlates.Count)];
                    MovePlate movePlateScript = selectedMovePlate.GetComponent<MovePlate>();
                    int targetX = movePlateScript.GetX();
                    int targetY = movePlateScript.GetY();

                    simulationState.MakeMove(selectedPiece, targetX, targetY);
                }
            }

            simulationState.NextPlayerTurn();
        }

        // Return a score indicating the outcome of the simulated game
        // You might use a custom evaluation function or score calculation
        // based on the game rules and objectives

        // float score = EvaluateScore(simulationState);
        float score = 10f; // delete score
        Debug.Log("Monte Carlo AI: Simulation completed. Score: " + score);

        return score;
    }

    private void UpdateStatistics(GameState gameState, float score)
    {
        Debug.Log("Monte Carlo AI: Updating statistics");

        // Update the statistics of the moves in the game state
        // You might keep track of visit counts, total scores, or other relevant information
        // for each move made during the Monte Carlo simulations
        // Update the statistics based on the outcome (score) of the simulated game
        // You can adjust this according to your specific MCTS implementation
        // and the requirements of your game
    }

    private int GetVisitCount(GameObject move)
    {
        // Retrieve the visit count for the given move
        // You need to implement this method based on your statistics structure
        // Return the visit count for the move
        return 0;
    }

    private float GetMoveScore(GameObject move)
    {
        // Retrieve the score for the given move
        // You need to implement this method based on your statistics structure
        // Return the score for the move
        return 0.0f;
    }

    public float EvaluateScore(GameState state)
    {
        Debug.Log("Monte Carlo AI: Evaluating score");

        // Evaluate the score for the given game state
        // You need to implement this method based on your game's rules and objectives
        // Calculate and return a score indicating the outcome of the game state
        return 0.0f;
    }

    private GameObject SelectBestMove(GameState gameState, float explorationParameter)
    {
        Debug.Log("Monte Carlo AI: Selecting best move");

        // Select the best move based on the statistics accumulated during the simulations
        // You can use various selection strategies, such as UCB1 or UCT (Upper Confidence Bounds for Trees)
        // Here, I'll provide a simple example using UCB1

        List<GameObject> legalMoves = gameState.GetLegalMoves();

        // Check if there are any legal moves available
        if (legalMoves.Count == 0)
        {
            return null;
        }

        float bestScore = float.MinValue;
        GameObject bestMove = null;

        foreach (GameObject move in legalMoves)
        {
            // Retrieve the statistics for the move
            // You need to implement this method based on your statistics structure
            int visitCount = GetVisitCount(move);
            float moveScore = GetMoveScore(move);

            // Calculate the UCB1 value for the move
            float ucb1 = moveScore / visitCount + explorationParameter * Mathf.Sqrt(Mathf.Log(gameState.GetTotalVisits()) / visitCount);

            if (ucb1 > bestScore)
            {
                bestScore = ucb1;
                bestMove = move;
            }
        }

        return bestMove;
    }



    private void MakeMove(GameObject movePlate)
    {
        Debug.Log("Monte Carlo AI: Making move");

        // Retrieve the necessary information from the move plate object
        MovePlate movePlateScript = movePlate.GetComponent<MovePlate>();
        GameObject selectedPiece = movePlateScript.GetReference();
        int startX = selectedPiece.GetComponent<Piece>().GetXBoard();
        int startY = selectedPiece.GetComponent<Piece>().GetYBoard();
        int targetX = movePlateScript.GetX();
        int targetY = movePlateScript.GetY();

        // Perform the actual move in your game
        // Implement the necessary logic to execute the move in your game
        selectedPiece.GetComponent<Piece>().MoveTo(targetX, targetY);
        selectedPiece.GetComponent<Piece>().GenerateMovementArrow();

        // Create a new MoveData object and push it to the move stack
        MoveData moveData = new MoveData(selectedPiece, startX, startY, targetX, targetY);
        AImoveStack.Push(moveData);
    }

    private void DestroyMovePlates(List<GameObject> movePlates)
    {
        foreach (GameObject movePlate in movePlates)
        {
            Destroy(movePlate);
        }
    }
}