using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;

public class aiR : MonoBehaviour
{
    private PieceGenerator pieceGenerator;
    private Game game;
    private GameObject controller;
    private GameObject sipliBoard;

    public string teamColor;

    private void Start()
    {
        pieceGenerator = GetComponent<PieceGenerator>();
        controller = GameObject.FindGameObjectWithTag("GameController");
        game = GameObject.FindGameObjectWithTag("GameController").GetComponent<Game>(); ;
        sipliBoard = GameObject.FindGameObjectWithTag("SipliBoard");
    }

    private void Update()
    {

        Game cp = controller.GetComponent<Game>();
        if (cp.GetCurrentPlayer() == teamColor && cp.IsGameOver() == false)
        {
            MakeMove();
        }

    }

    public static async Task AddDelayExample()
    {

        await Task.Delay(500);

    }

    public void MakeMove()
    {
        // Get all pieces controlled by the AI player
        List<GameObject> aiPieces = sipliBoard.GetComponent<PieceGenerator>().GetPiecesByPlayer(teamColor);

        // Filter out pieces without valid moves
        List<GameObject> piecesWithMoves = aiPieces.Where(piece => piece.GetComponent<Piece>().InitiateMovePlates()).ToList();

        if (piecesWithMoves.Count > 0)
        {
            // Select a random piece from the pieces with valid moves
            GameObject selectedPiece = piecesWithMoves[Random.Range(0, piecesWithMoves.Count)];

            // Get the move plates for the selected piece
            selectedPiece.GetComponent<Piece>().InitiateMovePlates();

            // Get the move plates generated by the selected piece
            GameObject[] movePlates = GameObject.FindGameObjectsWithTag("MovePlate");

            // Filter out move plates that lead to occupied spaces
            List<GameObject> validMovePlates = new List<GameObject>();
            List<GameObject> validNonAttackMovePlates = new List<GameObject>();

            foreach (GameObject movePlate in movePlates)
            {
                MovePlate movePlateScript = movePlate.GetComponent<MovePlate>();

                if (movePlateScript.GetReference() == selectedPiece)
                {
                    int targetX = movePlateScript.GetX();
                    int targetY = movePlateScript.GetY();

                    // Check if the target position is empty
                    if (sipliBoard.GetComponent<PieceGenerator>().GetPosition(targetX, targetY) == null)
                    {
                        validMovePlates.Add(movePlate);

                        if (!movePlateScript.attack)
                        {
                            validNonAttackMovePlates.Add(movePlate);
                        }
                    }
                }
            }

            Task.Run(async delegate
            {
                await AddDelayExample();

            }).Wait();

            float attackProbability = 0.7f;

            if (validMovePlates.Count > 0)
            {
                // Check if the selected piece is an "infinity" piece
                if (selectedPiece.GetComponent<Piece>().GetName().Contains("_infinity"))
                {
                    // Reduce the attack probability for "infinity" pieces
                    attackProbability = 0.3f;
                }

                if (validNonAttackMovePlates.Count > 0 && Random.value <= attackProbability)
                {
                    // Select a random valid non-attack move plate
                    GameObject selectedMovePlate = validNonAttackMovePlates[Random.Range(0, validNonAttackMovePlates.Count)];

                    // Get the coordinates of the selected move plate
                    MovePlate movePlateScript = selectedMovePlate.GetComponent<MovePlate>();
                    int targetX = movePlateScript.GetX();
                    int targetY = movePlateScript.GetY();

                    // Create a new MoveData object for the move
                    MoveData moveData = new MoveData(selectedPiece, selectedPiece.GetComponent<Piece>().GetXBoard(), selectedPiece.GetComponent<Piece>().GetYBoard(), targetX, targetY);

                    // Make the move by calling the necessary methods
                    selectedPiece.GetComponent<Piece>().MoveTo(targetX, targetY);

                    // Generate the movement arrow
                    selectedPiece.GetComponent<Piece>().GenerateMovementArrow();

                    // Push the move data to the move stack
                    game.moveStack.Push(moveData);

                }
                else
                {
                    // No valid non-attack moves, try to find attack move plates
                    List<GameObject> attackPlates = new List<GameObject>();

                    foreach (GameObject movePlate in movePlates)
                    {
                        MovePlate movePlateScript = movePlate.GetComponent<MovePlate>();

                        if (movePlateScript.attack && movePlateScript.GetReference() == selectedPiece)
                        {
                            attackPlates.Add(movePlate);

                        }
                    }

                    if (attackPlates.Count > 0)
                    {
                        // Select a random attack move plate
                        GameObject selectedMovePlate = attackPlates[Random.Range(0, attackPlates.Count)];

                        // Get the coordinates of the selected move plate
                        MovePlate movePlateScript = selectedMovePlate.GetComponent<MovePlate>();
                        int targetX = movePlateScript.GetX();
                        int targetY = movePlateScript.GetY();

                        // Get the attacked piece
                        GameObject attackedPiece = sipliBoard.GetComponent<PieceGenerator>().GetPosition(targetX, targetY);

                        // Resolve combat between the attacking and defending pieces
                        controller.GetComponent<CombatManager>().ResolveCombat(selectedPiece, attackedPiece);

                        // Create a new MoveData object for the move
                        MoveData moveData = new MoveData(selectedPiece, selectedPiece.GetComponent<Piece>().GetXBoard(), selectedPiece.GetComponent<Piece>().GetYBoard(), targetX, targetY);

                        // Set the combat data for the move
                        moveData.SetCombatData(true, attackedPiece);

                        // Move the attacking piece to the target position
                        selectedPiece.GetComponent<Piece>().MoveTo(targetX, targetY);
                        selectedPiece.GetComponent<Piece>().GenerateMovementArrow();

                        // Push the move data to the move stack
                        game.moveStack.Push(moveData);
                    }
                }
            }
        }
    }


}